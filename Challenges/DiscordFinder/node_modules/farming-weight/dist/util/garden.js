import { CROP_MILESTONES, GARDEN_EXP_REQUIRED, GARDEN_VISITORS } from "../constants/garden.js";
import { getCropFromName } from "./names.js";
/**
 * Gets user's current level based on experience
 * @param exp Current experience/progress
 * @param expRequired Array of the amount of experience required to reach each level, not cumulative
 * @param maxLevel Maximum level to return
 * @param overflow Calculate overflow levels
 */
export function getLevel(exp, expRequired, maxLevel, overflow = false) {
    let level = 0;
    let xp = exp;
    let maxed = true;
    for (const xpRequired of expRequired) {
        if ((xp -= xpRequired) > 0) {
            level++;
            if (level === maxLevel) {
                break;
            }
        }
        else {
            maxed = false;
            xp += xpRequired;
            break;
        }
    }
    const overflowing = !maxLevel && maxed && overflow;
    if (overflowing) {
        const overflowReq = expRequired.at(-1) ?? 0;
        if (overflowReq) {
            const overflowLevels = Math.floor(xp / overflowReq);
            level += overflowLevels;
            xp -= overflowLevels * overflowReq;
        }
    }
    const nextReq = (overflowing)
        ? expRequired.at(-1) ?? 0
        : expRequired[level];
    return {
        total: exp,
        level: level,
        maxed: maxed,
        ratio: maxed && !overflowing ? 1 : xp / (nextReq ?? xp),
        progress: xp,
        goal: maxed && !overflowing ? undefined : nextReq,
        next: maxed && !overflowing ? undefined : level + 1,
    };
}
export function getGardenLevel(exp, overflow = false) {
    return getLevel(exp, GARDEN_EXP_REQUIRED, undefined, overflow);
}
export function getCropMilestone(crop, collection, overflow = false) {
    return getLevel(collection, CROP_MILESTONES[crop], undefined, overflow);
}
export function getCropMilestones(crops, overflow = false) {
    const milestones = {};
    for (const [cropName, collection] of Object.entries(crops)) {
        const crop = getCropFromName(cropName);
        const col = typeof collection === 'string' ? parseInt(collection) : collection;
        if (isNaN(col) || !crop)
            continue;
        milestones[crop] = getLevel(col, CROP_MILESTONES[crop], undefined, overflow);
    }
    return milestones;
}
export function getCropMilestoneLevels(crops, overflow = false) {
    const milestones = {};
    for (const [cropName, collection] of Object.entries(crops)) {
        const crop = getCropFromName(cropName);
        const col = typeof collection === 'string' ? parseInt(collection) : collection ?? NaN;
        if (isNaN(col) || !crop)
            continue;
        milestones[crop] = getLevel(col, CROP_MILESTONES[crop], undefined, overflow).level;
    }
    return milestones;
}
export function getCropUpgrades(upgrades) {
    const cropUpgrades = {};
    for (const [cropName, upgrade] of Object.entries(upgrades)) {
        const crop = getCropFromName(cropName);
        if (!crop)
            continue;
        cropUpgrades[crop] = upgrade;
    }
    return cropUpgrades;
}
export function getGardenVisitor(visitor) {
    return GARDEN_VISITORS[visitor];
}
export function groupGardenVisitors(visitors) {
    const groups = {};
    for (const [visitorId, stats] of Object.entries(visitors)) {
        const visitor = getGardenVisitor(visitorId);
        if (!visitor)
            continue;
        groups[visitor.rarity] ??= [];
        groups[visitor.rarity].push({
            ...visitor,
            ...stats,
        });
    }
    for (const group of Object.values(groups)) {
        group.sort((a, b) => {
            if (b.visits === a.visits) {
                if (b.accepted === a.accepted) {
                    return a.name.localeCompare(b.name);
                }
                return b.accepted - a.accepted;
            }
            return b.visits - a.visits;
        });
    }
    return groups;
}
//# sourceMappingURL=garden.js.map