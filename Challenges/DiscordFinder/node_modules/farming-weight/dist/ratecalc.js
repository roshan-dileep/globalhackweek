"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GetCropInfo = exports.GetNPCProfit = exports.CalculateDetailedDrops = exports.CalculateExpectedDrops = exports.CalculateDetailedAverageDrops = exports.CalculateAverageDrops = void 0;
const crops_1 = require("./constants/crops");
const melon_1 = require("./crops/melon");
const pumpkin_1 = require("./crops/pumpkin");
const special_1 = require("./crops/special");
const crops = [
    crops_1.Crop.Cactus,
    crops_1.Crop.Carrot,
    crops_1.Crop.CocoaBeans,
    crops_1.Crop.Melon,
    crops_1.Crop.Mushroom,
    crops_1.Crop.NetherWart,
    crops_1.Crop.Potato,
    crops_1.Crop.Pumpkin,
    crops_1.Crop.SugarCane,
    crops_1.Crop.Wheat,
    crops_1.Crop.Seeds,
];
function CalculateAverageDrops(options) {
    const result = {};
    for (const crop of crops) {
        result[crop] = CalculateExpectedDrops({
            crop: crop,
            ...options,
        });
    }
    return result;
}
exports.CalculateAverageDrops = CalculateAverageDrops;
function CalculateDetailedAverageDrops(options) {
    const result = {};
    for (const crop of crops) {
        result[crop] = CalculateDetailedDrops({
            crop: crop,
            ...options,
        });
    }
    const wheat = result[crops_1.Crop.Wheat];
    const seeds = result[crops_1.Crop.Seeds];
    wheat.otherCollection['Seeds'] = seeds.collection;
    wheat.coinSources['Seeds'] = seeds.collection * crops_1.CROP_INFO[crops_1.Crop.Seeds].npc;
    if (options.bountiful) {
        wheat.coinSources['Bountiful (Seeds)'] = seeds.coinSources['Bountiful'] ?? 0;
    }
    wheat.npcCoins = Object.values(wheat.coinSources).reduce((a, b) => a + b, 0);
    return result;
}
exports.CalculateDetailedAverageDrops = CalculateDetailedAverageDrops;
function CalculateExpectedDrops(options) {
    const { farmingFortune, blocksBroken, crop } = options;
    const fortune = farmingFortune ?? crops_1.MAX_CROP_FORTUNE[crop] ?? 0;
    if (fortune <= 0 || blocksBroken < 0)
        return 0;
    const { drops } = GetCropInfo(crop);
    if (!drops)
        return 0;
    const baseDrops = blocksBroken * drops * (fortune * 0.01);
    switch (crop) {
        case crops_1.Crop.Cactus:
        case crops_1.Crop.Wheat:
        case crops_1.Crop.Mushroom:
        case crops_1.Crop.SugarCane:
            return Math.round(baseDrops);
        case crops_1.Crop.Carrot:
        case crops_1.Crop.CocoaBeans:
        case crops_1.Crop.NetherWart:
        case crops_1.Crop.Potato:
        case crops_1.Crop.Seeds:
            return Math.round(baseDrops - blocksBroken); // Replenish takes away one drop per block broken
        case crops_1.Crop.Pumpkin:
            return Math.round(baseDrops + (0, pumpkin_1.CalculatePumpkinPerkBonus)(blocksBroken));
        case crops_1.Crop.Melon:
            return Math.round(baseDrops + (0, melon_1.CalculateMelonPerkBonus)(blocksBroken));
        default:
            return 0;
    }
}
exports.CalculateExpectedDrops = CalculateExpectedDrops;
function CalculateDetailedDrops(options) {
    const result = {
        collection: 0,
        npcCoins: 0,
        fortune: 0,
        coinSources: {},
        otherCollection: {},
    };
    const { farmingFortune, blocksBroken, crop, bountiful } = options;
    let fortune = farmingFortune ?? crops_1.MAX_CROP_FORTUNE[crop] ?? 0;
    if (fortune <= 0 || blocksBroken < 0)
        return result;
    if (!bountiful && !farmingFortune) {
        fortune += 5;
    }
    result.fortune = fortune;
    const { drops, npc, breaks = 1, replenish = false } = GetCropInfo(crop);
    if (!drops)
        return result;
    const baseDrops = blocksBroken * drops * (fortune * 0.01);
    // Coin sources
    if (bountiful) {
        result.coinSources['Bountiful'] = Math.round(baseDrops * 0.2);
    }
    if (options.mooshroom) {
        result.coinSources['Mooshroom'] = Math.round(blocksBroken * breaks * crops_1.CROP_INFO[crops_1.Crop.Mushroom].npc);
        result.otherCollection['Mushroom'] = Math.round(blocksBroken * breaks);
    }
    const specialCrops = (0, special_1.CalculateAverageSpecialCrops)(blocksBroken, crop, 4);
    result.otherCollection[specialCrops.type] = Math.round(specialCrops.amount);
    result.coinSources[specialCrops.type] = Math.round(specialCrops.npc);
    let extraDrops = 0;
    switch (crop) {
        case crops_1.Crop.Pumpkin:
            extraDrops = Math.round((0, pumpkin_1.CalculatePumpkinPerkBonus)(blocksBroken));
            result.coinSources['Dicer RNG'] = Math.round(extraDrops * npc);
            result.collection = Math.round(baseDrops + extraDrops);
            result.coinSources['Collection'] = Math.round(baseDrops * npc);
            break;
        case crops_1.Crop.Melon:
            extraDrops = Math.round((0, melon_1.CalculateMelonPerkBonus)(blocksBroken));
            result.coinSources['Dicer RNG'] = Math.round(extraDrops * npc);
            result.collection = Math.round(baseDrops + extraDrops);
            result.coinSources['Collection'] = Math.round(baseDrops * npc);
            break;
        default:
            if (replenish) {
                // Replenish takes away one drop per block broken
                result.coinSources['Collection'] = Math.round((baseDrops - blocksBroken * breaks) * npc);
                result.collection = Math.round(baseDrops - blocksBroken * breaks);
                break;
            }
            result.coinSources['Collection'] = Math.round(baseDrops * npc);
            result.collection = Math.round(baseDrops);
            break;
    }
    result.npcCoins = Object.values(result.coinSources).reduce((a, b) => a + b, 0);
    return result;
}
exports.CalculateDetailedDrops = CalculateDetailedDrops;
function GetNPCProfit(crop, amount) {
    const { npc } = GetCropInfo(crop);
    if (!npc)
        return 0;
    return npc * amount;
}
exports.GetNPCProfit = GetNPCProfit;
function GetCropInfo(crop) {
    return crops_1.CROP_INFO[crop] ?? {};
}
exports.GetCropInfo = GetCropInfo;
//# sourceMappingURL=ratecalc.js.map