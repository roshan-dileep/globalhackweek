"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FarmingArmor = exports.ArmorSet = void 0;
const armor_1 = require("../constants/armor");
const enchants_1 = require("../constants/enchants");
const reforges_1 = require("../constants/reforges");
const skills_1 = require("../constants/skills");
const specialcrops_1 = require("../constants/specialcrops");
const special_1 = require("../crops/special");
const gems_1 = require("../util/gems");
const itemstats_1 = require("../util/itemstats");
class ArmorSet {
    get armor() {
        return [this.helmet ?? null, this.chestplate ?? null, this.leggings ?? null, this.boots ?? null];
    }
    constructor(armor) {
        armor.sort((a, b) => b.potential - a.potential);
        this.pieces = armor;
        this.helmet = armor.find((a) => a.slot === armor_1.GearSlot.Helmet);
        this.chestplate = armor.find((a) => a.slot === armor_1.GearSlot.Chestplate);
        this.leggings = armor.find((a) => a.slot === armor_1.GearSlot.Leggings);
        this.boots = armor.find((a) => a.slot === armor_1.GearSlot.Boots);
        this.recalculateFamilies();
    }
    getPiece(slot) {
        switch (slot) {
            case armor_1.GearSlot.Helmet:
                return this.helmet;
            case armor_1.GearSlot.Chestplate:
                return this.chestplate;
            case armor_1.GearSlot.Leggings:
                return this.leggings;
            case armor_1.GearSlot.Boots:
                return this.boots;
            default:
                return undefined;
        }
    }
    setPiece(armor) {
        switch (armor.slot) {
            case armor_1.GearSlot.Helmet:
                this.helmet = armor;
                break;
            case armor_1.GearSlot.Chestplate:
                this.chestplate = armor;
                break;
            case armor_1.GearSlot.Leggings:
                this.leggings = armor;
                break;
            case armor_1.GearSlot.Boots:
                this.boots = armor;
                break;
            default:
                return;
        }
        this.recalculateFamilies();
    }
    recalculateFamilies() {
        const families = new Map();
        const armor = this.armor.filter((a) => a);
        this.setBonuses = [];
        for (const piece of armor) {
            if (!piece.armor.family)
                continue;
            families.set(piece.armor.family, (families.get(piece.armor.family) ?? 0) + 1);
        }
        for (const [family, count] of families.entries()) {
            if (count < 2)
                continue;
            const bonus = armor_1.ARMOR_SET_BONUS[family];
            if (!bonus)
                continue;
            this.setBonuses.push({
                count,
                from: armor.filter((a) => a.armor.family === family).map((a) => a.slot),
                bonus,
                special: bonus.special,
            });
        }
        this.getFortuneBreakdown();
    }
    getFortuneBreakdown(reloadFamilies = false) {
        if (reloadFamilies) {
            this.recalculateFamilies();
        }
        let sum = 0;
        const breakdown = {};
        for (const piece of this.armor) {
            if (!piece)
                continue;
            const fortune = piece.fortune;
            if (fortune > 0) {
                breakdown[piece.item.name ?? ''] = fortune;
                sum += fortune;
            }
        }
        for (const { bonus, count } of this.setBonuses) {
            if (count < 2 || count > 4)
                continue;
            const fortune = bonus.stats?.[count]?.[reforges_1.Stat.FarmingFortune] ?? 0;
            if (fortune > 0) {
                breakdown[bonus.name] = fortune;
                sum += fortune;
            }
        }
        this.fortune = sum;
        return breakdown;
    }
    specialDropsCalc(blocksBroken, crop) {
        const special = specialcrops_1.MATCHING_SPECIAL_CROP[crop];
        const applicableBonuses = this.setBonuses.filter((b) => b.special?.includes(special));
        if (applicableBonuses.length === 0)
            return null;
        // Armor set counts need to be combined for special crops
        // There will only be 2 applicable bonuses at most when Fermento armor plus
        // a lower tier armor is used. Hypixel appeats to count these as the same
        // set bonus instead of rolling them separately.
        let count = 0;
        for (const bonus of applicableBonuses) {
            count += bonus.count;
        }
        return (0, special_1.calculateAverageSpecialCrops)(blocksBroken, crop, count);
    }
}
exports.ArmorSet = ArmorSet;
class FarmingArmor {
    get slot() {
        return this.armor.slot;
    }
    get potential() {
        if (!this.armor.family) {
            return this.fortune;
        }
        // Add the set bonus potential to the fortune
        return this.fortune + (armor_1.ARMOR_SET_BONUS[this.armor.family]?.piecePotential?.[reforges_1.Stat.FarmingFortune] ?? 0);
    }
    constructor(item, options) {
        this.options = options;
        this.item = item;
        const armor = armor_1.ARMOR_INFO[item.skyblockId];
        if (!armor) {
            throw new Error(`Unknown farming armor: ${item.name} (${item.skyblockId})`);
        }
        this.armor = armor;
        if (item.lore) {
            this.rarity = (0, itemstats_1.getRarityFromLore)(item.lore);
        }
        this.reforge = reforges_1.REFORGES[item.attributes?.modifier ?? ''] ?? undefined;
        this.reforgeStats = this.reforge?.tiers?.[this.rarity];
        this.recombobulated = this.item.attributes?.rarity_upgrades === '1';
        this.sumFortune();
    }
    setOptions(options) {
        this.options = options;
        this.fortune = this.sumFortune();
    }
    sumFortune() {
        this.fortuneBreakdown = {};
        let sum = 0;
        // Base fortune
        const base = this.armor.stats?.[reforges_1.Stat.FarmingFortune] ?? 0;
        if (base > 0) {
            this.fortuneBreakdown['Base Stats'] = base;
            sum += base;
        }
        // Per farming level stats like Rancher's Boots
        if (this.armor.perLevelStats?.skill === skills_1.Skill.Farming && this.options?.farmingLevel) {
            const perLevel = this.armor.perLevelStats?.stats[reforges_1.Stat.FarmingFortune] ?? 0;
            if (perLevel > 0) {
                this.fortuneBreakdown['Farming Level'] = perLevel * this.options.farmingLevel;
                sum += perLevel * this.options.farmingLevel;
            }
        }
        // Reforge stats
        const reforge = this.reforgeStats?.stats?.[reforges_1.Stat.FarmingFortune] ?? 0;
        if (reforge > 0) {
            this.fortuneBreakdown[this.reforge?.name ?? 'Reforge'] = reforge;
            sum += reforge;
        }
        // Gems
        const peridot = (0, gems_1.getPeridotFortune)(this.rarity, this.item);
        if (peridot > 0) {
            this.fortuneBreakdown['Peridot Gems'] = peridot;
            sum += peridot;
        }
        // Enchantments
        const enchantments = Object.entries(this.item.enchantments ?? {});
        for (const [enchant, level] of enchantments) {
            if (!level)
                continue;
            const enchantment = enchants_1.FARMING_ARMOR_ENCHANTS[enchant];
            if (!enchantment || !level)
                continue;
            const fortune = enchantment.levels?.[level]?.[reforges_1.Stat.FarmingFortune] ?? 0;
            if (fortune > 0) {
                this.fortuneBreakdown[enchantment.name] = fortune;
                sum += fortune;
            }
        }
        this.fortune = sum;
        return sum;
    }
    static isValid(item) {
        return armor_1.ARMOR_INFO[item.skyblockId] !== undefined;
    }
    static fromArray(items, options) {
        return items
            .filter((item) => FarmingArmor.isValid(item))
            .map((item) => new FarmingArmor(item, options))
            .sort((a, b) => b.fortune - a.fortune);
    }
}
exports.FarmingArmor = FarmingArmor;
//# sourceMappingURL=farmingarmor.js.map